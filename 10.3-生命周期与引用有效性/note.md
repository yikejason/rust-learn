### 生命周期
- Rust 的每个引用都有自己的生命周期
- 生命周期：引用保持有效的作用域
- 大多数情况：生命周期是隐式的、可被推断的
- 当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期

## 生命周期 - 避免悬垂引用 （dangling reference）
- 生命周期的主要目标：避免悬垂引用

## 借用检查器
- Rust 编译器的借用检查器：比较作用域来判断所有借用是否合法。

## 函数中的泛型生命周期
eg: 
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("{}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

## 生命周期标注语法
- 生命周期的标注不会改变引用的生命周期长度
- 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用
- 生命周期的标注：描述了多个引用生命周期间的关系，但不影响生命周期

- 生命周期参数名:
  - 以‘ 开头
  - 通常全小写且非常短
  - 很多人使用 ’a

- 生命周期标注的位置
  - 在引用的 & 符号后
  - 使用空格将标注和引用类型分开

## 生命周期标注 - 例子
- &i32   // 一个引用
- &’a i32  // 带有显式生命周期的引用
- &’a mut i32  // 带有显示生命周期的可变引用


## 函数签名中的生命周期标注
- 泛型生命周期参数声明在：函数名和参数列表之间的 <> 里
- 生命周期'a的实际生命周期是：x 和 y两个生命周期中较小的那个

## 深入理解生命周期

